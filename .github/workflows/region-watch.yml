name: Region watch (GitHub Markdown)
on:
  schedule: [{ cron: "23 */6 * * *" }]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  watch:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install requests

      - name: Run diff
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # boosts rate limits
        run: |
          python .region-watch/diff_regions.py > region_diff.json
          cat region_diff.json

      - name: Commit snapshot if changed
        run: |
          git config user.email "bot@users.noreply.github.com"
          git config user.name "region-bot"
          git add .region-watch/regions_snapshot.json .region-watch/history region_diff.json
          git diff --cached --quiet || git commit -m "Update region snapshot"
          git push

      - name: Notify via GitHub issue
        if: ${{ hashFiles('region_diff.json') != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const diff = JSON.parse(fs.readFileSync('region_diff.json','utf8'));
            const hasChange = Object.values(diff.changes || {}).some(c => {
              const overallAdded = c?.all?.added ?? [];
              const overallRemoved = c?.all?.removed ?? [];
              const skuChanges = Object.values(c?.skus || {});
              const skuDelta = skuChanges.some(sku => (sku?.added?.length || sku?.removed?.length || sku?.sku_removed));
              return overallAdded.length || overallRemoved.length || skuDelta || c?.model_removed;
            });
            if (!hasChange) { core.info('No region changes'); return; }

            const owner = context.repo.owner, repo = context.repo.repo;
            const title = 'Azure AI model region watch';
            const label = 'region-watch';
            const bodyLines = ['Model region changes detected:'];
            for (const [m, ch] of Object.entries(diff.changes)) {
                const added = ch?.all?.added ?? [];
                const removed = ch?.all?.removed ?? [];
                if (added.length)  bodyLines.push(`• ${m}: added -> ${added.join(', ')}`);
                if (removed.length) bodyLines.push(`• ${m}: removed -> ${removed.join(', ')}`);
                for (const [skuKey, skuChange] of Object.entries(ch?.skus || {})) {
                  const label = skuChange?.label || skuKey;
                  const skuAdded = skuChange?.added ?? [];
                  const skuRemoved = skuChange?.removed ?? [];
                  if (skuAdded.length) bodyLines.push(`  - ${label} (${skuKey}): added -> ${skuAdded.join(', ')}`);
                  if (skuRemoved.length) bodyLines.push(`  - ${label} (${skuKey}): removed -> ${skuRemoved.join(', ')}`);
                  if (skuChange?.sku_removed) bodyLines.push(`  - ${label} (${skuKey}): sku removed`);
                }
                if (ch?.model_removed) bodyLines.push('  - model removed');
            }
            bodyLines.push('\n/cc @jinle @org/team-name'); // adjust mentions

            // find existing open issue
            const issues = await github.paginate(github.rest.issues.listForRepo, {owner, repo, labels: label, state: 'open'});
            if (issues.length) {
                await github.rest.issues.createComment({owner, repo, issue_number: issues[0].number, body: bodyLines.join('\n')});
            } else {
                await github.rest.issues.create({owner, repo, title, body: bodyLines.join('\n'), labels: [label], assignees: ['jinle']});
            }