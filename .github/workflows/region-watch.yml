name: Region watch (GitHub Markdown)
on:
  schedule: [{ cron: "23 */6 * * *" }]
  workflow_dispatch:

permissions:
  contents: write
  issues: write

jobs:
  watch:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install requests

      - name: Run diff
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # boosts rate limits
        run: |
          python .region-watch/diff_regions.py > region_diff.json
          cat region_diff.json

      - name: Detect changes
        id: detect
        run: |
          python - <<'PY'
          import json
          from pathlib import Path

          diff = json.loads(Path("region_diff.json").read_text(encoding="utf-8"))
          Path(".region-watch").mkdir(exist_ok=True)

          def has_change_block(block: dict) -> bool:
              if not isinstance(block, dict):
                  return False
              added = block.get("added") or []
              removed = block.get("removed") or []
              return bool(added or removed)

          def has_change_entry(entry: dict) -> bool:
              if not isinstance(entry, dict):
                  return False
              if has_change_block(entry.get("all") or {}):
                  return True
              if entry.get("model_removed"):
                  return True
              for sku_change in (entry.get("skus") or {}).values():
                  if has_change_block(sku_change) or sku_change.get("sku_removed"):
                      return True
              return False

          detected = any(
              has_change_entry(change)
              for change in (diff.get("changes") or {}).values()
          )

          Path(".region-watch/has_change.flag").write_text(
              "true" if detected else "false", encoding="utf-8"
          )
          PY
          echo "has_change=$(cat .region-watch/has_change.flag)" >> "$GITHUB_OUTPUT"

      - name: Render REGION_AVAILABILITY.md
        if: ${{ steps.detect.outputs.has_change == 'true' }}
        run: python .region-watch/render_markdown.py

      - name: Commit snapshot if changed
        run: |
          git config user.email "bot@users.noreply.github.com"
          git config user.name "region-bot"
          git add .region-watch/regions_snapshot.json .region-watch/history region_diff.json REGION_AVAILABILITY.md
          git diff --cached --quiet || git commit -m "Update region snapshot"
          git push

      - name: Notify via GitHub issue
        if: ${{ hashFiles('region_diff.json') != '' && steps.detect.outputs.has_change == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const diff = JSON.parse(fs.readFileSync('region_diff.json','utf8'));
            const hasChange = Object.values(diff.changes || {}).some(c => {
              const overallAdded = c?.all?.added ?? [];
              const overallRemoved = c?.all?.removed ?? [];
              const skuChanges = Object.values(c?.skus || {});
              const skuDelta = skuChanges.some(sku => (sku?.added?.length || sku?.removed?.length || sku?.sku_removed));
              return overallAdded.length || overallRemoved.length || skuDelta || c?.model_removed;
            });
            if (!hasChange) { core.info('No region changes'); return; }

            const owner = context.repo.owner, repo = context.repo.repo;
            const title = 'Azure AI model region watch';
            const label = 'region-watch';
            const bodyLines = ['Model region changes detected:'];
            for (const [m, ch] of Object.entries(diff.changes)) {
                const added = ch?.all?.added ?? [];
                const removed = ch?.all?.removed ?? [];
                if (added.length)  bodyLines.push(`• ${m}: added -> ${added.join(', ')}`);
                if (removed.length) bodyLines.push(`• ${m}: removed -> ${removed.join(', ')}`);
                for (const [skuKey, skuChange] of Object.entries(ch?.skus || {})) {
                  const label = skuChange?.label || skuKey;
                  const skuAdded = skuChange?.added ?? [];
                  const skuRemoved = skuChange?.removed ?? [];
                  if (skuAdded.length) bodyLines.push(`  - ${label} (${skuKey}): added -> ${skuAdded.join(', ')}`);
                  if (skuRemoved.length) bodyLines.push(`  - ${label} (${skuKey}): removed -> ${skuRemoved.join(', ')}`);
                  if (skuChange?.sku_removed) bodyLines.push(`  - ${label} (${skuKey}): sku removed`);
                }
                if (ch?.model_removed) bodyLines.push('  - model removed');
            }
            bodyLines.push('\n/cc @JinLee794 @org/team-name'); // adjust mentions

            // find existing open issue
            const issues = await github.paginate(github.rest.issues.listForRepo, {owner, repo, labels: label, state: 'open'});
            const assignees = (process.env.ISSUE_ASSIGNEES || '')
              .split(',')
              .map(v => v.trim())
              .filter(Boolean);
            if (issues.length) {
                await github.rest.issues.createComment({owner, repo, issue_number: issues[0].number, body: bodyLines.join('\n')});
            } else {
                const issuePayload = {owner, repo, title, body: bodyLines.join('\n'), labels: [label]};
                if (assignees.length) {
                  issuePayload.assignees = assignees;
                }
                try {
                  await github.rest.issues.create(issuePayload);
                } catch (error) {
                  core.warning(`Failed to create issue with assignees (${assignees.join(', ')}): ${error}`);
                  if (assignees.length) {
                    delete issuePayload.assignees;
                    await github.rest.issues.create(issuePayload);
                  } else {
                    throw error;
                  }
                }
            }
